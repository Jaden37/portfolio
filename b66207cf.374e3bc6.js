(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{105:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return i})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return u}));var a=t(3),r=t(7),o=(t(0),t(128)),l={id:"6_0_Pods",title:"What is a pod ?"},i={unversionedId:"Kubernetes/2_management_APIServer_&_Pod/6_0_Pods",id:"Kubernetes/2_management_APIServer_&_Pod/6_0_Pods",isDocsHomePage:!1,title:"What is a pod ?",description:"what pod",source:"@site/docs/Kubernetes/2_management_APIServer_&_Pod/6_0_Pods.md",slug:"/Kubernetes/2_management_APIServer_&_Pod/6_0_Pods",permalink:"/docs/Kubernetes/2_management_APIServer_&_Pod/6_0_Pods",editUrl:"https://github.com/j-peguet/portfolio/blob/master/docs/Kubernetes/2_management_APIServer_&_Pod/6_0_Pods.md",version:"current",sidebar:"docs",previous:{title:"Annotations",permalink:"/docs/Kubernetes/2_management_APIServer_&_Pod/5_3_Annotations"},next:{title:"Single container Pods",permalink:"/docs/Kubernetes/2_management_APIServer_&_Pod/6_1_Single_Pods"}},s=[{value:"Comment les pods manipules les conteneurs",id:"comment-les-pods-manipules-les-conteneurs",children:[]},{value:"Relationship between Controllers and Pods",id:"relationship-between-controllers-and-pods",children:[{value:"Working with Pods - kubectl",id:"working-with-pods---kubectl",children:[]}]},{value:"Common anti-pattern for multi-container Pods",id:"common-anti-pattern-for-multi-container-pods",children:[]},{value:"Shared Resources Inside a Pod",id:"shared-resources-inside-a-pod",children:[{value:"Networking",id:"networking",children:[]},{value:"Storage",id:"storage",children:[]}]},{value:"Pod Lifecycle",id:"pod-lifecycle",children:[]},{value:"Stopping/Terminating Pods",id:"stoppingterminating-pods",children:[]},{value:"Persistency of Pods",id:"persistency-of-pods",children:[]},{value:"Container Restart Policy",id:"container-restart-policy",children:[]},{value:"Commands",id:"commands",children:[]},{value:"Defining Pod Health",id:"defining-pod-health",children:[{value:"What type of checks ?",id:"what-type-of-checks-",children:[]},{value:"Configure Container Probes",id:"configure-container-probes",children:[]},{value:"livenessProbe",id:"livenessprobe",children:[]},{value:"readinessProbe",id:"readinessprobe",children:[]},{value:"Commands",id:"commands-1",children:[]}]}],c={toc:s};function u(e){var n=e.components,l=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,l,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("img",{alt:"what pod",src:t(194).default})),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Unit of scheduling"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Allocating work - by the scheduler in the node"),Object(o.b)("li",{parentName:"ul"},"A process that\u2019s running in your cluster - when is up and consuming resources"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Unit of deployment"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Inside your application configuration"),Object(o.b)("li",{parentName:"ul"},"Resources associated - Networking and Storage")))),Object(o.b)("p",null,"Le pod permet une abstraction par dessus le management des conteneurs (au niveau de la configuration des resources et du r\xe9seau)."),Object(o.b)("h2",{id:"comment-les-pods-manipules-les-conteneurs"},"Comment les pods manipules les conteneurs"),Object(o.b)("p",null,"Deux grandes familles:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"/docs/Kubernetes/2_management_APIServer_&_Pod/6_1_Single_Pods"},"Single Container Pods"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Single application inside a container deployed in our cluster"),Object(o.b)("li",{parentName:"ul"},"Most common deployment"),Object(o.b)("li",{parentName:"ul"},"Generally a single process running in a container"),Object(o.b)("li",{parentName:"ul"},"Often leads to easier application scaling"),Object(o.b)("li",{parentName:"ul"},'"Is a pod running a container running a single process on a node in our cluster"'))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"/docs/Kubernetes/2_management_APIServer_&_Pod/6_2_Multi_Pods"},"Multi-containers Pods"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"More than one container wrapped up in a pod"),Object(o.b)("li",{parentName:"ul"},"For very tightly coupled applications - producer/ consumer relationship"),Object(o.b)("li",{parentName:"ul"},"Scheduling processes together"),Object(o.b)("li",{parentName:"ul"},"Requirement on some shared resource"),Object(o.b)("li",{parentName:"ul"},"Usually something generating data while the other process consumes"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Don\u2019t")," use this to influence scheduling, we use other techniques for that! (labels, node selector)")))),Object(o.b)("h2",{id:"relationship-between-controllers-and-pods"},"Relationship between Controllers and Pods"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Controllers have the responsability to keep your apps in the desired state"),Object(o.b)("li",{parentName:"ul"},"Responsible for starting and stopping Pods - based on configuration"),Object(o.b)("li",{parentName:"ul"},"Application scaling - if you have the resources"),Object(o.b)("li",{parentName:"ul"},"Application recovery - if a pod goes offline or becomes unavailable, Kubernetes make sure you have the correct number of pods up and running"),Object(o.b)("li",{parentName:"ul"},"You ",Object(o.b)("strong",{parentName:"li"},"DON'T")," want to run bare/naked Pods - bare/naked pod, is a pod deployed without controller (deployment, replica set, deamon set, etc...)",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Because they won\u2019t be recreated in the event of a failure")))),Object(o.b)("h3",{id:"working-with-pods---kubectl"},"Working with Pods - kubectl"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-bash"},"kubectl exec -it POD1 --container CONTAINER1 -- /bin/bash\nkubectl port-forward pod POD1 LOCALPORT:CONTAINERPORT\n")),Object(o.b)("h2",{id:"common-anti-pattern-for-multi-container-pods"},"Common anti-pattern for multi-container Pods"),Object(o.b)("p",null,"Attention lors de la cr\xe9ation d'un pods avec plusieurs conteneurs."),Object(o.b)("p",null,"Nous ne voulons pas d'un Pod avec un conteneur web & DB."),Object(o.b)("p",null,"Cela peut para\xeetre une bonne id\xe9e (\xe9change de donn\xe9e rapide). Mais cela pose de 2 soucis majeurs:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"R\xe9cup\xe9ration - Si un pod meurs quels sont mes choix entre un service web stateless et une bdd statefull, quel controller utiliser ?"),Object(o.b)("li",{parentName:"ul"},"Limits Scaling - comme les conteneurs sont li\xe9s si j'ai besoin uniquement d'un serveur web en plus, une BDD sera \xe9galement d\xe9ploy\xe9e.")),Object(o.b)("p",null,Object(o.b)("img",{alt:"multi-container Pods",src:t(195).default})),Object(o.b)("h2",{id:"shared-resources-inside-a-pod"},"Shared Resources Inside a Pod"),Object(o.b)("h3",{id:"networking"},"Networking"),Object(o.b)("p",null,"Containers in a pod share the same Linux operating system-level namespace. This isn't the same Kubernetes namespace. Since they share the same network namespace, to be able to communicate with each other."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Shared loopback interface, used for communication over localhost"),Object(o.b)("li",{parentName:"ul"},"Be mindful of application port conflicts")),Object(o.b)("h3",{id:"storage"},"Storage"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Each container image has it\u2019s own file system"),Object(o.b)("li",{parentName:"ul"},"Volumes are defined at the Pod level"),Object(o.b)("li",{parentName:"ul"},"Shared amongst the containers in a Pod"),Object(o.b)("li",{parentName:"ul"},"Mounted into the containers\u2019 file system"),Object(o.b)("li",{parentName:"ul"},"Common way for containers to exchange data")),Object(o.b)("h2",{id:"pod-lifecycle"},"Pod Lifecycle"),Object(o.b)("p",null,Object(o.b)("img",{alt:"Pod lifecycle",src:t(196).default})),Object(o.b)("h2",{id:"stoppingterminating-pods"},"Stopping/Terminating Pods"),Object(o.b)("p",null,Object(o.b)("img",{alt:"Stopping/Terminating Pods",src:t(197).default})),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-bash"},"#Change the grace-period for a specific pod\nkubectl delete pod --grace-period=<second>\n")),Object(o.b)("p",null,"In some scenarios where you might need to specify the force deletion of a pod, which immediately delete the records in the API Server and etcd. It might not be able to shut down the actual application itself. The value of this is by ripping out the metadata about the pod resource that's up and running is that, well, you've kind of abandoned that pod, deleted the metadata, but you can now go and recreate that pod if you needed it to be the same name. Otherwise you have a naming conflict and this pod kind of hanging on that you conldn't delete."),Object(o.b)("p",null,"So, forced deletion deletes the metadata. It might leave that process up running, so you will have to go clean that up if it didn't clean itself up."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-bash"},"# Force deletion - Immediately deletes records in API an etcd\nkubectl delete pod --grace-period=0 --force\n")),Object(o.b)("h2",{id:"persistency-of-pods"},"Persistency of Pods"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"A Pod is never redeployed"),Object(o.b)("li",{parentName:"ul"},"If a Pod stops, a new one is created based on its Controller - no state transition between the previous execution"),Object(o.b)("li",{parentName:"ul"},"Go back to the original container image(s) in the Pod definition")),Object(o.b)("p",null,"How do we deal with things like application configuration or application statefull ?"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Configuration is managed externally",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Pod Manifests, secrets and ConfigMaps - Passwords, connexionStrings \u27a1\ufe0f stored in the cluster"),Object(o.b)("li",{parentName:"ul"},"Passing environment variables into containers"))),Object(o.b)("li",{parentName:"ul"},"Data Persistency is managed externally",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"PersistentVolume"),Object(o.b)("li",{parentName:"ul"},"PersistentVolumeClaim")))),Object(o.b)("h2",{id:"container-restart-policy"},"Container Restart Policy"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"A container in a Pod can restart independent of the Pod"),Object(o.b)("li",{parentName:"ul"},"Applies to containers inside a Pod and defined inside the Pod\u2019s Spec"),Object(o.b)("li",{parentName:"ul"},"The Pod is the environment the container runs in"),Object(o.b)("li",{parentName:"ul"},"Not rescheduled to another Node, but restarted by the Kubelet on that Node"),Object(o.b)("li",{parentName:"ul"},"Restarts with an exponential backoff, 10s, 20s, 40s capped at 5m and reset to 0 after 10m of successful runtime")),Object(o.b)("p",null,"Containers restart policy has 3 different configuration:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Always (default) - will restart all containers inside a Pod"),Object(o.b)("li",{parentName:"ul"},"OnFailure - Non-graceful termination"),Object(o.b)("li",{parentName:"ul"},"Never")),Object(o.b)("p",null,"How to configure it"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-pod\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n  restartPolicy: OnFailure\n")),Object(o.b)("h2",{id:"commands"},"Commands"),Object(o.b)("p",null,"Let's create a file nammed 'pod.yaml'"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: hello-world-pod\nspec:\n  containers:\n  - name: hello-world\n    image: gcr.io/google-samples/hello-app:1.0\n    ports:\n    - containerPort: 80\n")),Object(o.b)("p",null,"and 'pod-restart-policy.yaml'"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: hello-world-onfailure-pod\nspec:\n  containers:\n  - name: hello-world\n    image: gcr.io/google-samples/hello-app:1.0\n  restartPolicy: OnFailure\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: hello-world-never-pod\nspec:\n  containers:\n  - name: hello-world\n    image: gcr.io/google-samples/hello-app:1.0\n  restartPolicy: Never\n")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-bash"},"#Start up kubectl get events --watch and background it.\nkubectl get events --watch &\nclear\n\n#Create a pod...we can see the scheduling, container pulling and container starting.\nkubectl apply -f pod.yaml\n\n#We've used exec to launch a shell before, but we can use it to launch ANY program inside a container.\n#Let's use killall to kill the hello-app process inside our container\nkubectl exec -it hello-world-pod -- /bin/sh \nps\nexit\n\n#We still have our kubectl get events running in the background, so we see if re-create the container automatically.\nkubectl exec -it hello-world-pod -- /usr/bin/killall hello-app\n\n#Our restart count increased by 1 after the container needed to be restarted.\nkubectl get pods\n\n#Look at Containers->State, Last State, Reason, Exit Code, Restart Count and Events\n#This is because the container restart policy is Always by default\nkubectl describe pod hello-world-pod\n\n#Cleanup time\nkubectl delete pod hello-world-pod\n\n#Kill our watch\nfg\nctrl+c\n")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-bash"},"#Remember...we can ask the API server what it knows about an object, in this case our restartPolicy\nkubectl explain pods.spec.restartPolicy\n\n#Create our pods with the restart policy\nmore pod-restart-policy.yaml\nkubectl apply -f pod-restart-policy.yaml\n\n#Check to ensure both pods are up and running, we can see the restarts is 0\nkubectl get pods \n\n#Let's kill our apps in both our pods and see how the container restart policy reacts\nkubectl exec -it hello-world-never-pod -- /usr/bin/killall hello-app\nkubectl get pods\n\n#Review container state, reason, exit code, ready and contitions Ready, ContainerReady\nkubectl describe pod hello-world-never-pod\n\n#let's use killall to terminate the process inside our container. \nkubectl exec -it hello-world-onfailure-pod -- /usr/bin/killall hello-app\n\n#We'll see 1 restart on the pod with the OnFailure restart policy.\nkubectl get pods \n\n#Let's kill our app again, with the same signal.\nkubectl exec -it hello-world-onfailure-pod -- /usr/bin/killall hello-app\n\n#Check its status, which is now Error too...why? The backoff.\nkubectl get pods \n\n#Let's check the events, we hit the backoff loop. 10 second wait. Then it will restart.\n#Also check out State and Last State.\nkubectl describe pod hello-world-onfailure-pod \n\n#Check its status, should be Running...after the Backoff timer expires.\nkubectl get pods \n\n#Now let's look at our Pod statuses\nkubectl delete pod hello-world-never-pod\nkubectl delete pod hello-world-onfailure-pod\n")),Object(o.b)("h2",{id:"defining-pod-health"},"Defining Pod Health"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},'A Pod is considered ready when all containers are "running"'),Object(o.b)("li",{parentName:"ul"},"But we\u2019d like to be able to understand a little more about our applications"),Object(o.b)("li",{parentName:"ul"},"We can add additional intelligence to our"),Object(o.b)("li",{parentName:"ul"},"Pod\u2019s state and health"),Object(o.b)("li",{parentName:"ul"},"Container Probes",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"livenessProbe",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Runs a diagnostic check on a container"),Object(o.b)("li",{parentName:"ul"},"Per container setting"),Object(o.b)("li",{parentName:"ul"},"On failure, the Kubelet restarts the container"),Object(o.b)("li",{parentName:"ul"},"Container Restart Policy"),Object(o.b)("li",{parentName:"ul"},"Give Kubernetes a better understanding of our application"))),Object(o.b)("li",{parentName:"ul"},"readinessProbe",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Runs a diagnostic check on the container"),Object(o.b)("li",{parentName:"ul"},"Per container setting"),Object(o.b)("li",{parentName:"ul"},"On startup, your application won\u2019t receive traffic until ready (until the readinessProbe have success)"),Object(o.b)("li",{parentName:"ul"},"On failure, removes Pod from load balancing or replication controller (the container is not restarted)"),Object(o.b)("li",{parentName:"ul"},"For applications have long startup times"),Object(o.b)("li",{parentName:"ul"},"Prevents users from seeing errors")))))),Object(o.b)("h3",{id:"what-type-of-checks-"},"What type of checks ?"),Object(o.b)("p",null,Object(o.b)("img",{alt:"types checks",src:t(198).default}),"\n3 types de checks:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Exec",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Execute une ligne dans le conteneurs et regarde le code de sortie de ce process"))),Object(o.b)("li",{parentName:"ul"},"tcpSocker",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Regarde si un port est ouvert (pour lancer un outil de diagnostique, ou port d'un programme)"))),Object(o.b)("li",{parentName:"ul"},"httpGet",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Fait une requ\xeate URL et regarde le code http de sortie")))),Object(o.b)("p",null,"3 types d'erreurs en sortie:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Success",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"R\xe9ussite du processus"))),Object(o.b)("li",{parentName:"ul"},"Failure",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Erreur d'un test sur le conteneur"))),Object(o.b)("li",{parentName:"ul"},"Unknown",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Erreur li\xe9 au processus du diagnostique")))),Object(o.b)("h3",{id:"configure-container-probes"},"Configure Container Probes"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"initialDelaySeconds - number of seconds after the container has started before running container probes"),Object(o.b)("li",{parentName:"ul"},"periodSeconds - interval when the test probe are execute, default 10 seconds"),Object(o.b)("li",{parentName:"ul"},"timeoutSeconds - number of seconds the prode test before giving up"),Object(o.b)("li",{parentName:"ul"},"failureThreshold - number of missed checks before reporting failure, default 3"),Object(o.b)("li",{parentName:"ul"},"successThreshold - number of probes to be considered successful and live, default 1")),Object(o.b)("h3",{id:"livenessprobe"},"livenessProbe"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"spec:\n  containers:\n    ...\n    livenessProbe:\n      tcpSocket:\n        port: 8080\n      initialDelaySeconds: 15\n      periodSeconds: 20\n")),Object(o.b)("h3",{id:"readinessprobe"},"readinessProbe"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"spec:\n  containers:\n    ...\n    readinessProbe:\n      tcpSocket:\n        port: 8080\n      initialDelaySeconds: 5\n      periodSeconds: 10\n")),Object(o.b)("h3",{id:"commands-1"},"Commands"),Object(o.b)("p",null,"Create file container-probes.yaml"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: hello-world\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: hello-world\n  template:\n    metadata:\n      labels:\n        app: hello-world\n    spec:\n      containers:\n      - name: hello-world\n        image: gcr.io/google-samples/hello-app:1.0\n        ports:\n        - containerPort: 8080\n        livenessProbe:\n          tcpSocket:\n            port: 8081\n          initialDelaySeconds: 10\n          periodSeconds: 5\n        readinessProbe:\n          httpGet:\n            path: /\n            port: 8081\n          initialDelaySeconds: 10\n          periodSeconds: 5\n")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-bash"},"#Start a watch to see the events associated with our probes.\nkubectl get events --watch &\nclear\n\n#We have a single container pod app, in a Deployment that has both a liveness probe and a readiness probe\ncat container-probes.yaml\n\n#Send in our deployment, after 10 seconds, our liveness and readiness probes will fail.\n#The liveness probe will kill the current pod, and recreate one.\nkubectl apply -f container-probes.yaml\n\n#kill our watch\nfg\nctrl+c\n\n#We can see that our container isn't ready 0/1 and it's Restarts are increasing.\nkubectl get pods\n\n#Let's figure out what's wrong\n#1. We can see in the events. The Liveness and Readiness probe failures.\n#2. Under Containers, Liveness and Readiness, we can see the current configuration. And the current probe configuration. Both are pointing to 8081.\n#3. Under Containers, Ready and Container Contidtions, we can see that the container isn't ready.\n#4. Our Container Port is 8080, that's what we want our probes, probings. \nkubectl describe pods\n\n#So let's go ahead and change the probes to 8080\nvi container-probes.yaml\n\n#And send that change into the API Server for this deployment.\nkubectl apply -f container-probes.yaml\n\n#Confirm our probes are pointing to the correct container port now, which is 8080.\n \n#Let's check our status, a couple of things happened there.\n#1. Our Deployment ReplicaSet created a NEW Pod, when we pushed in the new deployment configuration.\n#2. It's not immediately ready because of our initialDelaySeconds which is 10 seconds.\n#3. If we wait long enough, the livenessProbe will kill the original Pod and it will go away.\n#4. Leaving us with the one pod in our Deployment's ReplicaSet\nkubectl get pods \n\nkubectl delete deployment hello-world\n")))}u.isMDXComponent=!0},128:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return m}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),u=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=u(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},b=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(t),b=a,m=d["".concat(l,".").concat(b)]||d[b]||p[b]||o;return t?r.a.createElement(m,i(i({ref:n},c),{},{components:t})):r.a.createElement(m,i({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=b;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var c=2;c<o;c++)l[c]=t[c];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},194:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/what_pod-67e7b11f81e0ae53ad12ef694b9a47ec.png"},195:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/multi_pods-9f33ea8659ba494b1558ded638a95386.png"},196:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/pod_lifecycle-94f2e386e6b2085f70d86a03e7e5c6d4.png"},197:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/terminate_pods-ceb2e99ac595a9c964aa754455403658.png"},198:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/types_checks-0a84b894a40ef4e928092e16572d9c82.png"}}]);